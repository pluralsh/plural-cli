# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: RootQueryType
  mutation: RootMutationType
  subscription: RootSubscriptionType
}

type Account {
  availableFeatures: PlanFeatures
  backgroundColor: String
  billingAddress: Address
  billingCustomerId: String
  clusterCount: String
  delinquentAt: DateTime
  domainMappings: [DomainMapping]
  grandfatheredUntil: DateTime
  icon: String
  id: ID!
  insertedAt: DateTime
  name: String
  rootUser: User
  subscription: PlatformSubscription
  updatedAt: DateTime
  userCount: String
  workosConnectionId: String
}

type ActionItem {
  link: String!
  type: ActionItemType!
}

type Address {
  city: String
  country: String
  line1: String
  line2: String
  name: String
  state: String
  zip: String
}

type ApplyLock {
  id: ID!
  insertedAt: DateTime
  lock: String
  owner: User
  repository: Repository
  updatedAt: DateTime
}

type Artifact {
  arch: String
  blob: String
  filesize: Int
  id: ID
  insertedAt: DateTime
  name: String
  platform: ArtifactPlatform
  readme: String
  sha: String
  type: ArtifactType
  updatedAt: DateTime
}

type Audit {
  action: String!
  actor: User
  city: String
  country: String
  group: Group
  id: ID!
  image: DockerImage
  insertedAt: DateTime
  integrationWebhook: IntegrationWebhook
  ip: String
  latitude: String
  longitude: String
  repository: Repository
  role: Role
  updatedAt: DateTime
  user: User
  version: Version
}

type AuditConnection {
  edges: [AuditEdge]
  pageInfo: PageInfo!
}

type AuditEdge {
  cursor: String
  node: Audit
}

type AuthorizationUrl {
  provider: ScmProvider!
  url: String!
}

type Card {
  brand: String!
  expMonth: Int!
  expYear: Int!
  id: ID!
  last4: String!
  name: String
}

type CardConnection {
  edges: [CardEdge]
  pageInfo: PageInfo!
}

type CardEdge {
  cursor: String
  node: Card
}

type CategoryInfo {
  category: Category
  count: Int
  tags(after: String, before: String, first: Int, last: Int, q: String): GroupedTagConnection
}

type ChangeInstructions {
  instructions: String
  script: String
}

type Chart {
  dependencies: Dependencies
  description: String
  id: ID
  insertedAt: DateTime
  installation: ChartInstallation
  latestVersion: String
  name: String!
  repository: Repository
  tags: [VersionTag]
  updatedAt: DateTime
}

type ChartConnection {
  edges: [ChartEdge]
  pageInfo: PageInfo!
}

type ChartEdge {
  cursor: String
  node: Chart
}

type ChartInstallation {
  chart: Chart
  id: ID
  insertedAt: DateTime
  installation: Installation
  updatedAt: DateTime
  version: Version
}

type ChartInstallationConnection {
  edges: [ChartInstallationEdge]
  pageInfo: PageInfo!
}

type ChartInstallationEdge {
  cursor: String
  node: ChartInstallation
}

type ClosureItem {
  dep: Dependency
  helm: Chart
  terraform: Terraform
}

type CloudShell {
  aesKey: String!
  alive: Boolean!
  cluster: String!
  gitUrl: String!
  id: ID!
  insertedAt: DateTime
  missing: [String]
  provider: Provider!
  region: String!
  status: ShellStatus
  subdomain: String!
  updatedAt: DateTime
}

"A Kubernetes cluster that can be used to deploy applications on with Plural."
type Cluster {
  "The account that the cluster belongs to."
  account: Account
  "The URL of the console running on the cluster."
  consoleUrl: String
  "The domain name used for applications deployed on the cluster."
  domain: String
  "The git repository URL for the cluster."
  gitUrl: String
  "The ID of the cluster."
  id: ID!
  insertedAt: DateTime
  "The name of the cluster."
  name: String!
  "The user that owns the cluster."
  owner: User
  "The last time the cluster was pinged."
  pingedAt: DateTime
  "The cluster's cloud provider."
  provider: Provider!
  "The upgrade queue for applications running on the cluster."
  queue: UpgradeQueue
  "The source of the cluster."
  source: Source
  updatedAt: DateTime
  "pending upgrades for each installed app"
  upgradeInfo: [UpgradeInfo]
}

type ClusterConnection {
  edges: [ClusterEdge]
  pageInfo: PageInfo!
}

"A dependncy reference between clusters"
type ClusterDependency {
  "the cluster holding this dependency"
  cluster: Cluster
  "the source cluster of this dependency"
  dependency: Cluster
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
}

type ClusterEdge {
  cursor: String
  node: Cluster
}

type ClusterInformation {
  gitCommit: String
  id: ID!
  insertedAt: DateTime
  platform: String
  updatedAt: DateTime
  version: String
}

type Community {
  discord: String
  gitUrl: String
  homepage: String
  slack: String
  twitter: String
  videos: [String]
}

type ConsentRequest {
  requestedScope: [String]
  skip: Boolean
}

type Crd {
  blob: String
  id: ID!
  insertedAt: DateTime
  name: String!
  updatedAt: DateTime
}

type Cvss {
  attackComplexity: VulnGrade
  attackVector: VulnVector
  availability: VulnGrade
  confidentiality: VulnGrade
  integrity: VulnGrade
  privilegesRequired: VulnGrade
  userInteraction: VulnRequirement
}

type DeferredReason {
  message: String
  package: String
  repository: String
}

type DeferredUpdate {
  attempts: Int
  chartInstallation: ChartInstallation
  dequeueAt: DateTime
  id: ID!
  insertedAt: DateTime
  messages: [DeferredReason]
  pending: Boolean
  terraformInstallation: TerraformInstallation
  updatedAt: DateTime
  version: Version
}

type DeferredUpdateConnection {
  edges: [DeferredUpdateEdge]
  pageInfo: PageInfo!
}

type DeferredUpdateEdge {
  cursor: String
  node: DeferredUpdate
}

type DemoProject {
  credentials: String
  id: ID!
  insertedAt: DateTime
  projectId: String!
  ready: Boolean
  state: DemoProjectState
  updatedAt: DateTime
}

type Dependencies {
  application: Boolean
  breaking: Boolean
  cliVsn: String
  dependencies: [Dependency]
  instructions: ChangeInstructions
  outputs: Map
  providerVsn: String
  providerWirings: Map
  providers: [Provider]
  secrets: [String]
  wait: Boolean
  wirings: Wirings
}

type Dependency {
  name: String
  optional: Boolean
  repo: String
  type: DependencyType
  version: String
}

type DeviceLogin {
  deviceToken: String!
  loginUrl: String!
}

type DnsAccessPolicy {
  bindings: [PolicyBinding]
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
}

type DnsDomain {
  accessPolicy: DnsAccessPolicy
  account: Account
  creator: User
  dnsRecords(after: String, before: String, first: Int, last: Int): DnsRecordConnection
  id: ID!
  insertedAt: DateTime
  name: String!
  updatedAt: DateTime
}

type DnsDomainConnection {
  edges: [DnsDomainEdge]
  pageInfo: PageInfo!
}

type DnsDomainEdge {
  cursor: String
  node: DnsDomain
}

type DnsRecord {
  cluster: String!
  creator: User
  domain: DnsDomain
  id: ID!
  insertedAt: DateTime
  name: String!
  provider: Provider!
  records: [String]
  type: DnsRecordType!
  updatedAt: DateTime
}

type DnsRecordConnection {
  edges: [DnsRecordEdge]
  pageInfo: PageInfo!
}

type DnsRecordEdge {
  cursor: String
  node: DnsRecord
}

type DockerImage {
  digest: String!
  dockerRepository: DockerRepository
  grade: ImageGrade
  id: ID!
  insertedAt: DateTime
  scanCompletedAt: DateTime
  scannedAt: DateTime
  tag: String
  updatedAt: DateTime
  vulnerabilities: [Vulnerability]
}

type DockerImageConnection {
  edges: [DockerImageEdge]
  pageInfo: PageInfo!
}

type DockerImageEdge {
  cursor: String
  node: DockerImage
}

type DockerRepository {
  id: ID!
  insertedAt: DateTime
  metrics(offset: String, precision: String, tag: String): [Metric]
  name: String!
  public: Boolean
  repository: Repository
  updatedAt: DateTime
}

type DockerRepositoryConnection {
  edges: [DockerRepositoryEdge]
  pageInfo: PageInfo!
}

type DockerRepositoryEdge {
  cursor: String
  node: DockerRepository
}

type DomainMapping {
  account: Account
  domain: String!
  enableSso: Boolean
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
}

type EabCredential {
  cluster: String!
  hmacKey: String!
  id: ID!
  insertedAt: DateTime
  keyId: String!
  provider: Provider!
  updatedAt: DateTime
}

type File {
  blob: String!
  contentType: String
  filename: String
  filesize: Int
  height: Int
  id: ID!
  insertedAt: DateTime
  mediaType: MediaType
  message: IncidentMessage!
  updatedAt: DateTime
  width: Int
}

type FileConnection {
  edges: [FileEdge]
  pageInfo: PageInfo!
}

type FileContent {
  content: String!
  path: String!
}

type FileEdge {
  cursor: String
  node: File
}

type Follower {
  id: ID!
  incident: Incident
  insertedAt: DateTime
  preferences: NotificationPreferences
  updatedAt: DateTime
  user: User!
}

type FollowerConnection {
  edges: [FollowerEdge]
  pageInfo: PageInfo!
}

type FollowerEdge {
  cursor: String
  node: Follower
}

type GeoMetric {
  count: Int
  country: String
}

type GitConfiguration {
  branch: String
  name: String
  root: String
  url: String
}

type Group {
  description: String
  global: Boolean
  id: ID!
  insertedAt: DateTime
  name: String!
  updatedAt: DateTime
}

type GroupConnection {
  edges: [GroupEdge]
  pageInfo: PageInfo!
}

type GroupEdge {
  cursor: String
  node: Group
}

type GroupMember {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type GroupMemberConnection {
  edges: [GroupMemberEdge]
  pageInfo: PageInfo!
}

type GroupMemberEdge {
  cursor: String
  node: GroupMember
}

type GroupedTag {
  count: Int!
  tag: String!
}

type GroupedTagConnection {
  edges: [GroupedTagEdge]
  pageInfo: PageInfo!
}

type GroupedTagEdge {
  cursor: String
  node: GroupedTag
}

type ImageDependency {
  id: ID!
  image: DockerImage!
  insertedAt: DateTime
  updatedAt: DateTime
  version: Version!
}

type ImageLayer {
  diffId: String
  digest: String
}

type ImpersonationPolicy {
  bindings: [ImpersonationPolicyBinding]
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
}

type ImpersonationPolicyBinding {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type Incident {
  clusterInformation: ClusterInformation
  creator: User!
  description: String
  files(after: String, before: String, first: Int, last: Int): FileConnection
  follower: Follower
  followers(after: String, before: String, first: Int, last: Int): FollowerConnection
  history(after: String, before: String, first: Int, last: Int): IncidentHistoryConnection
  id: ID!
  insertedAt: DateTime
  messages(after: String, before: String, first: Int, last: Int): IncidentMessageConnection
  nextResponseAt: DateTime
  notificationCount: Int
  owner: User
  postmortem: Postmortem
  repository: Repository!
  severity: Int!
  status: IncidentStatus!
  subscription: SlimSubscription
  tags: [Tag]
  title: String!
  updatedAt: DateTime
}

type IncidentChange {
  key: String!
  next: String
  prev: String
}

type IncidentConnection {
  edges: [IncidentEdge]
  pageInfo: PageInfo!
}

type IncidentDelta {
  delta: Delta
  payload: Incident
}

type IncidentEdge {
  cursor: String
  node: Incident
}

type IncidentHistory {
  action: IncidentAction!
  actor: User!
  changes: [IncidentChange]
  id: ID!
  incident: Incident!
  insertedAt: DateTime
  updatedAt: DateTime
}

type IncidentHistoryConnection {
  edges: [IncidentHistoryEdge]
  pageInfo: PageInfo!
}

type IncidentHistoryEdge {
  cursor: String
  node: IncidentHistory
}

type IncidentMessage {
  creator: User!
  entities: [MessageEntity]
  file: File
  id: ID!
  incident: Incident!
  insertedAt: DateTime
  reactions: [Reaction]
  text: String!
  updatedAt: DateTime
}

type IncidentMessageConnection {
  edges: [IncidentMessageEdge]
  pageInfo: PageInfo!
}

type IncidentMessageDelta {
  delta: Delta
  payload: IncidentMessage
}

type IncidentMessageEdge {
  cursor: String
  node: IncidentMessage
}

"An installation of an application."
type Installation {
  acmeKeyId: String
  acmeSecret: String
  "Whether the application should auto upgrade."
  autoUpgrade: Boolean
  "A YAML object of context."
  context: Map
  "The installation's ID."
  id: ID!
  insertedAt: DateTime
  license: String
  "The license key for the application."
  licenseKey: String
  "The OIDC provider for the application."
  oidcProvider: OidcProvider
  "The last ping time of an installed application."
  pingedAt: DateTime
  "The application that was installed."
  repository: Repository
  "The subscription for the application."
  subscription: RepositorySubscription
  "The tag to track for auto upgrades."
  trackTag: String!
  updatedAt: DateTime
  "The user that installed the application."
  user: User
}

type InstallationConnection {
  edges: [InstallationEdge]
  pageInfo: PageInfo!
}

type InstallationEdge {
  cursor: String
  node: Installation
}

type Integration {
  description: String
  icon: String
  id: ID!
  insertedAt: DateTime
  name: String!
  publisher: Publisher
  repository: Repository
  sourceUrl: String
  spec: Map
  tags: [Tag]
  type: String
  updatedAt: DateTime
}

type IntegrationConnection {
  edges: [IntegrationEdge]
  pageInfo: PageInfo!
}

type IntegrationEdge {
  cursor: String
  node: Integration
}

type IntegrationWebhook {
  account: Account
  actions: [String]
  id: ID!
  insertedAt: DateTime
  logs(after: String, before: String, first: Int, last: Int): WebhookLogConnection
  name: String!
  secret: String!
  updatedAt: DateTime
  url: String!
}

type IntegrationWebhookConnection {
  edges: [IntegrationWebhookEdge]
  pageInfo: PageInfo!
}

type IntegrationWebhookEdge {
  cursor: String
  node: IntegrationWebhook
}

type Invite {
  account: Account
  email: String
  existing: Boolean!
  expiresAt: DateTime
  id: ID!
  insertedAt: DateTime
  secureId: String
  updatedAt: DateTime
  user: User
}

type InviteConnection {
  edges: [InviteEdge]
  pageInfo: PageInfo!
}

type InviteEdge {
  cursor: String
  node: Invite
}

type Invoice {
  amountDue: Int!
  amountPaid: Int!
  createdAt: DateTime
  currency: String!
  hostedInvoiceUrl: String
  lines: [InvoiceItem]
  number: String!
  status: String
}

type InvoiceConnection {
  edges: [InvoiceEdge]
  pageInfo: PageInfo!
}

type InvoiceEdge {
  cursor: String
  node: Invoice
}

type InvoiceItem {
  amount: Int!
  currency: String!
  description: String
}

type KeyBackup {
  digest: String!
  id: ID!
  insertedAt: DateTime
  name: String!
  repositories: [String!]
  updatedAt: DateTime
  user: User!
  value: String!
}

type KeyBackupConnection {
  edges: [KeyBackupEdge]
  pageInfo: PageInfo!
}

type KeyBackupEdge {
  cursor: String
  node: KeyBackup
}

type License {
  name: String
  url: String
}

type Limit {
  dimension: String!
  quantity: Int!
}

type LineItem {
  cost: Int!
  dimension: String!
  name: String!
  period: String
  type: PlanType
}

type LoginMethodResponse {
  authorizeUrl: String
  loginMethod: LoginMethod!
  token: String
}

type LoginRequest {
  requestedScope: [String]
  subject: String
}

type MessageEntity {
  endIndex: Int
  id: ID!
  insertedAt: DateTime
  startIndex: Int
  text: String
  type: MessageEntityType!
  updatedAt: DateTime
  user: User
}

type Metric {
  name: String!
  tags: [MetricTag]
  values: [MetricValue]
}

type MetricTag {
  name: String!
  value: String!
}

type MetricValue {
  time: DateTime
  value: Int
}

type NetworkConfiguration {
  pluralDns: Boolean
  subdomain: String
}

type Notification {
  actor: User!
  id: ID!
  incident: Incident
  insertedAt: DateTime
  message: IncidentMessage
  msg: String
  repository: Repository
  type: NotificationType!
  updatedAt: DateTime
  user: User!
}

type NotificationConnection {
  edges: [NotificationEdge]
  pageInfo: PageInfo!
}

type NotificationEdge {
  cursor: String
  node: Notification
}

type NotificationPreferences {
  incidentUpdate: Boolean
  mention: Boolean
  message: Boolean
}

type OauthInfo {
  authorizeUrl: String!
  provider: OauthProvider!
}

type OauthIntegration {
  account: Account
  id: ID!
  insertedAt: DateTime
  service: OauthService!
  updatedAt: DateTime
}

type OauthResponse {
  redirectTo: String!
}

type OauthSettings {
  authMethod: OidcAuthMethod!
  uriFormat: String!
}

type OidcLogin {
  city: String
  country: String
  id: ID!
  insertedAt: DateTime
  ip: String
  latitude: String
  longitude: String
  owner: User
  repository: Repository
  updatedAt: DateTime
  user: User
}

type OidcLoginConnection {
  edges: [OidcLoginEdge]
  pageInfo: PageInfo!
}

type OidcLoginEdge {
  cursor: String
  node: OidcLogin
}

type OidcProvider {
  authMethod: OidcAuthMethod!
  bindings: [OidcProviderBinding]
  clientId: String!
  clientSecret: String!
  configuration: OuathConfiguration
  consent: ConsentRequest
  id: ID!
  insertedAt: DateTime
  redirectUris: [String]
  updatedAt: DateTime
}

type OidcProviderBinding {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type OidcSettings {
  authMethod: OidcAuthMethod!
  domainKey: String
  subdomain: Boolean
  uriFormat: String
  uriFormats: [String]
}

type OidcStepResponse {
  consent: ConsentRequest
  login: LoginRequest
  repository: Repository
}

type OnboardingChecklist {
  dismissed: Boolean
  status: OnboardingChecklistState
}

type OuathConfiguration {
  authorizationEndpoint: String
  issuer: String
  jwksUri: String
  tokenEndpoint: String
  userinfoEndpoint: String
}

type PackageScan {
  errors: [ScanError]
  grade: ImageGrade
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  violations: [ScanViolation]
}

type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PersistedToken {
  audits(after: String, before: String, first: Int, last: Int): PersistedTokenAuditConnection
  id: ID
  insertedAt: DateTime
  metrics: [GeoMetric]
  token: String
  updatedAt: DateTime
}

type PersistedTokenAudit {
  city: String
  count: Int
  country: String
  id: ID
  insertedAt: DateTime
  ip: String
  latitude: String
  longitude: String
  timestamp: DateTime
  updatedAt: DateTime
}

type PersistedTokenAuditConnection {
  edges: [PersistedTokenAuditEdge]
  pageInfo: PageInfo!
}

type PersistedTokenAuditEdge {
  cursor: String
  node: PersistedTokenAudit
}

type PersistedTokenConnection {
  edges: [PersistedTokenEdge]
  pageInfo: PageInfo!
}

type PersistedTokenEdge {
  cursor: String
  node: PersistedToken
}

type Plan {
  cost: Int!
  default: Boolean
  id: ID!
  insertedAt: DateTime
  lineItems: PlanLineItems
  metadata: PlanMetadata
  name: String!
  period: String
  serviceLevels: [ServiceLevel]
  updatedAt: DateTime
  visible: Boolean!
}

type PlanFeature {
  description: String!
  name: String!
}

type PlanFeatures {
  audit: Boolean
  userManagement: Boolean
  vpn: Boolean
}

type PlanLineItems {
  included: [Limit]
  items: [LineItem]
}

type PlanMetadata {
  features: [PlanFeature]
  freeform: Map
}

type PlatformMetrics {
  clusters: Int
  publishers: Int
  repositories: Int
  rollouts: Int
}

type PlatformPlan {
  cost: Int!
  enterprise: Boolean
  features: PlanFeatures
  id: ID!
  insertedAt: DateTime
  lineItems: [PlatformPlanItem]
  name: String!
  period: PaymentPeriod!
  updatedAt: DateTime
  visible: Boolean!
}

type PlatformPlanItem {
  cost: Int!
  dimension: LineItemDimension!
  externalId: String
  name: String!
  period: PaymentPeriod!
}

type PlatformSubscription {
  externalId: String
  id: ID!
  lineItems: [PlatformSubscriptionLineItems]
  plan: PlatformPlan
}

type PlatformSubscriptionLineItems {
  dimension: LineItemDimension!
  externalId: String
  quantity: Int!
}

type PluralConfiguration {
  gitCommit: String
  registry: String
  stripeConnectId: String
  stripePublishableKey: String
}

type PolicyBinding {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type Postmortem {
  actionItems: [ActionItem]
  content: String!
  creator: User!
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
}

type PublicKey {
  content: String!
  digest: String!
  id: ID!
  insertedAt: DateTime
  name: String!
  updatedAt: DateTime
  user: User!
}

type PublicKeyConnection {
  edges: [PublicKeyEdge]
  pageInfo: PageInfo!
}

type PublicKeyEdge {
  cursor: String
  node: PublicKey
}

type Publisher {
  address: Address
  avatar: String
  backgroundColor: String
  billingAccountId: String
  community: Community
  description: String
  id: ID
  insertedAt: DateTime
  name: String!
  owner: User
  phone: String
  repositories: [Repository]
  updatedAt: DateTime
}

type PublisherConnection {
  edges: [PublisherEdge]
  pageInfo: PageInfo!
}

type PublisherEdge {
  cursor: String
  node: Publisher
}

type Reaction {
  creator: User!
  insertedAt: DateTime
  message: IncidentMessage!
  name: String!
  updatedAt: DateTime
}

type Recipe {
  description: String
  id: ID!
  insertedAt: DateTime
  name: String!
  oidcEnabled: Boolean
  oidcSettings: OidcSettings
  primary: Boolean
  private: Boolean
  provider: Provider
  recipeDependencies: [Recipe]
  recipeSections: [RecipeSection]
  repository: Repository
  restricted: Boolean
  tests: [RecipeTest]
  updatedAt: DateTime
}

type RecipeCondition {
  field: String!
  operation: Operation!
  value: String
}

type RecipeConfiguration {
  args: [String]
  condition: RecipeCondition
  default: String
  documentation: String
  functionName: String
  longform: String
  name: String
  optional: Boolean
  placeholder: String
  type: Datatype
  validation: RecipeValidation
}

type RecipeConnection {
  edges: [RecipeEdge]
  pageInfo: PageInfo!
}

type RecipeEdge {
  cursor: String
  node: Recipe
}

type RecipeItem {
  chart: Chart
  configuration: [RecipeConfiguration]
  id: ID
  insertedAt: DateTime
  recipeSection: RecipeSection
  terraform: Terraform
  updatedAt: DateTime
}

type RecipeSection {
  configuration: [RecipeConfiguration]
  id: ID
  index: Int
  insertedAt: DateTime
  recipe: Recipe
  recipeItems: [RecipeItem]
  repository: Repository
  updatedAt: DateTime
}

type RecipeTest {
  args: [TestArgument]
  message: String
  name: String!
  type: TestType!
}

type RecipeValidation {
  message: String!
  regex: String
  type: ValidationType!
}

"Container for all resources to create an application."
type Repository {
  "The artifacts of the application."
  artifacts: [Artifact]
  "The category of the application."
  category: Category
  "The community links of the application."
  community: Community
  darkIcon: String
  "The default tag to deploy."
  defaultTag: String
  "The description of the application."
  description: String
  "The documentation of the application."
  docs: [FileContent]
  "The documentation of the application."
  documentation: String
  "If the application can be edited by the current user."
  editable: Boolean
  "The git URL of the application."
  gitUrl: String
  "The homepage of the application."
  homepage: String
  icon: String
  "The application's ID."
  id: ID!
  insertedAt: DateTime
  "The installation of the application by a user."
  installation: Installation
  "The license of the application."
  license: License
  "The main branch of the application."
  mainBranch: String
  "The name of the application."
  name: String!
  "Notes about the application rendered after deploying and displayed to the user."
  notes: String
  "The OAuth settings for the application."
  oauthSettings: OauthSettings
  "The available plans for the application."
  plans: [Plan]
  "Whether the application is private."
  private: Boolean
  "The application's public key."
  publicKey: String
  "The application publisher."
  publisher: Publisher
  "The README of the application."
  readme: String
  "The recipes used to install the application."
  recipes: [Recipe]
  "A map of secrets of the application."
  secrets: Map
  "The tags of the application."
  tags: [Tag]
  "Whether the application is trending."
  trending: Boolean
  updatedAt: DateTime
  "Whether the application is verified."
  verified: Boolean
}

type RepositoryConnection {
  edges: [RepositoryEdge]
  pageInfo: PageInfo!
}

type RepositoryEdge {
  cursor: String
  node: Repository
}

type RepositorySubscription {
  customerId: String
  externalId: String
  id: ID!
  installation: Installation
  invoices(after: String, before: String, first: Int, last: Int): InvoiceConnection
  lineItems: SubscriptionLineItems
  plan: Plan
}

type RepositorySubscriptionConnection {
  edges: [RepositorySubscriptionEdge]
  pageInfo: PageInfo!
}

type RepositorySubscriptionEdge {
  cursor: String
  node: RepositorySubscription
}

type ResetToken {
  email: String!
  externalId: ID!
  id: ID!
  insertedAt: DateTime
  type: ResetTokenType!
  updatedAt: DateTime
  user: User!
}

type Role {
  account: Account
  description: String
  id: ID!
  insertedAt: DateTime
  name: String!
  permissions: [Permission]
  repositories: [String]
  roleBindings: [RoleBinding]
  updatedAt: DateTime
}

type RoleBinding {
  group: Group
  id: ID!
  insertedAt: DateTime
  updatedAt: DateTime
  user: User
}

type RoleConnection {
  edges: [RoleEdge]
  pageInfo: PageInfo!
}

type RoleEdge {
  cursor: String
  node: Role
}

type Roles {
  admin: Boolean
}

type Rollout {
  count: Int
  cursor: ID
  event: String
  heartbeat: DateTime
  id: ID!
  insertedAt: DateTime
  repository: Repository
  status: RolloutStatus!
  updatedAt: DateTime
}

type RolloutConnection {
  edges: [RolloutEdge]
  pageInfo: PageInfo!
}

type RolloutDelta {
  delta: Delta
  payload: Rollout
}

type RolloutEdge {
  cursor: String
  node: Rollout
}

type RootMutationType {
  acceptIncident(id: ID!): Incident
  acceptLogin(challenge: String!): OauthResponse
  acquireLock(repository: String!): ApplyLock
  cancelPlatformSubscription: PlatformSubscription
  completeIncident(id: ID!, postmortem: PostmortemAttributes!): Incident
  createArtifact(attributes: ArtifactAttributes!, repositoryId: ID, repositoryName: String): Artifact
  createCard(address: AddressAttributes, source: String!): Account
  "Create a new cluster."
  createCluster(
    "The input attributes for the cluster that will be created."
    attributes: ClusterAttributes!
  ): Cluster
  "adds a dependency for this cluster to gate future upgrades"
  createClusterDependency(destId: ID!, sourceId: ID!): ClusterDependency
  createCrd(attributes: CrdAttributes!, chartId: ID, chartName: ChartName): Crd
  createDemoProject: DemoProject
  createDnsRecord(attributes: DnsRecordAttributes!, cluster: String!, provider: Provider!): DnsRecord
  createDomain(attributes: DnsDomainAttributes!): DnsDomain
  createGroup(attributes: GroupAttributes!): Group
  createGroupMember(groupId: ID!, userId: ID!): GroupMember
  createIncident(attributes: IncidentAttributes!, repository: String, repositoryId: ID): Incident
  createInstallation(repositoryId: ID!): Installation
  createIntegration(attributes: IntegrationAttributes!, repositoryName: String!): Integration
  createIntegrationWebhook(attributes: IntegrationWebhookAttributes!): IntegrationWebhook
  createInvite(attributes: InviteAttributes!): Invite
  createKeyBackup(attributes: KeyBackupAttributes!): KeyBackup
  createMessage(attributes: IncidentMessageAttributes!, incidentId: ID!): IncidentMessage
  createOauthIntegration(attributes: OauthAttributes!): OauthIntegration
  createOidcProvider(
    attributes: OidcAttributes!,
    "The installation ID"
    installationId: ID!
  ): OidcProvider
  createPlan(attributes: PlanAttributes!, repositoryId: ID!): Plan
  createPlatformSubscription(planId: ID!): PlatformSubscription
  createPublicKey(attributes: PublicKeyAttributes!): PublicKey
  createPublisher(attributes: PublisherAttributes!): Publisher
  createQueue(attributes: UpgradeQueueAttributes!): UpgradeQueue
  createReaction(messageId: ID!, name: String!): IncidentMessage
  createRecipe(attributes: RecipeAttributes!, repositoryId: String, repositoryName: String): Recipe
  createRepository(attributes: RepositoryAttributes!, id: ID): Repository
  createResetToken(attributes: ResetTokenAttributes!): Boolean
  createRole(attributes: RoleAttributes!): Role
  createServiceAccount(attributes: ServiceAccountAttributes!): User
  createShell(attributes: CloudShellAttributes!): CloudShell
  createStack(attributes: StackAttributes!): Stack
  createSubscription(attributes: SubscriptionAttributes, installationId: ID!, planId: ID!): RepositorySubscription
  createTerraform(attributes: TerraformAttributes!, repositoryId: ID!): Terraform
  createTest(attributes: TestAttributes!, name: String, repositoryId: ID): Test
  createToken: PersistedToken
  createUserEvent(attributes: UserEventAttributes!): Boolean
  createWebhook(attributes: WebhookAttributes!): Webhook
  createZoom(attributes: MeetingAttributes!): ZoomMeeting
  deleteCard(id: ID!): Account
  deleteChartInstallation(id: ID!): ChartInstallation
  "Delete a cluster."
  deleteCluster(
    "The name of the cluster."
    name: String!,
    "The cluster's cloud provider."
    provider: Provider!
  ): Cluster
  deleteDemoProject: DemoProject
  deleteDnsRecord(name: String!, type: DnsRecordType!): DnsRecord
  deleteDomain(id: ID!): DnsDomain
  deleteEabKey(cluster: String, id: ID, provider: Provider): EabCredential
  deleteGroup(groupId: ID!): Group
  deleteGroupMember(groupId: ID!, userId: ID!): GroupMember
  deleteIncident(id: ID!): Incident
  deleteInstallation(id: ID!): Installation
  deleteIntegrationWebhook(id: ID!): IntegrationWebhook
  deleteInvite(id: ID, secureId: String): Invite
  deleteKeyBackup(name: String!): KeyBackup
  deleteMessage(id: ID!): IncidentMessage
  deletePlatformSubscription: Account
  deletePublicKey(id: ID!): PublicKey
  deleteReaction(messageId: ID!, name: String!): IncidentMessage
  deleteRecipe(id: ID!): Recipe
  deleteRepository(repositoryId: ID!): Repository
  deleteRole(id: ID!): Role
  deleteShell: CloudShell
  deleteStack(name: String!): Stack
  deleteTerraform(id: ID!): Terraform
  deleteToken(id: ID!): PersistedToken
  deleteUser(id: ID!): User
  destroyCluster(domain: String!, name: String!, provider: Provider!): Boolean
  deviceLogin: DeviceLogin
  externalToken: String
  followIncident(attributes: FollowerAttributes!, id: ID!): Follower
  impersonateServiceAccount(email: String, id: ID): User
  installBundle(context: ContextAttributes!, name: String!, oidc: Boolean!, repo: String!): [Installation]
  installChart(attributes: ChartInstallationAttributes!, installationId: ID!): ChartInstallation
  installRecipe(context: Map!, recipeId: ID!): [Installation]
  installStack(name: String!, provider: Provider!): [Recipe]
  installStackShell(context: ContextAttributes!, name: String!, oidc: Boolean!): [Recipe]
  installTerraform(attributes: TerraformInstallationAttributes!, installationId: ID!): TerraformInstallation
  linkPublisher(token: String!): Publisher
  login(deviceToken: String, email: String!, password: String!): User
  loginToken(deviceToken: String, token: String!): User
  oauthCallback(code: String!, deviceToken: String, host: String, provider: OauthProvider!): User
  oauthConsent(challenge: String!, scopes: [String]): OauthResponse
  passwordlessLogin(token: String!): User
  pingWebhook(id: ID!, message: String, repo: String!): WebhookResponse
  "moves up the upgrade waterline for a user"
  promote: User
  provisionDomain(name: String!): DnsDomain
  publishLogs(id: ID!, logs: String!): TestStep
  quickStack(provider: Provider!, repositoryIds: [ID]): Stack
  readNotifications(incidentId: ID): Int
  realizeInvite(id: String!): User
  realizeResetToken(attributes: ResetTokenRealization!, id: ID!): Boolean
  rebootShell: CloudShell
  releaseLock(attributes: LockAttributes!, repository: String!): ApplyLock
  resetInstallations: Int
  restartShell: Boolean
  setupShell: CloudShell
  signup(account: AccountAttributes, attributes: UserAttributes!, deviceToken: String, inviteId: String): User
  ssoCallback(code: String!, deviceToken: String): User
  stopShell: Boolean
  transferDemoProject(organizationId: String!): DemoProject
  unfollowIncident(id: ID!): Follower
  uninstallTerraform(id: ID!): TerraformInstallation
  unlockRepository(name: String!): Int
  updateAccount(attributes: AccountAttributes!): Account
  updateChart(attributes: ChartAttributes!, id: ID!): Chart
  updateChartInstallation(attributes: ChartInstallationAttributes!, chartInstallationId: ID!): ChartInstallation
  updateDockerRepository(attributes: DockerRepositoryAttributes!, id: ID!): DockerRepository
  updateDomain(attributes: DnsDomainAttributes!, id: ID!): DnsDomain
  updateGroup(attributes: GroupAttributes!, groupId: ID!): Group
  updateIncident(attributes: IncidentAttributes!, id: ID!): Incident
  updateInstallation(attributes: InstallationAttributes!, id: ID!): Installation
  updateIntegrationWebhook(attributes: IntegrationWebhookAttributes!, id: ID!): IntegrationWebhook
  updateLineItem(attributes: LimitAttributes!, subscriptionId: ID!): RepositorySubscription
  updateMessage(attributes: IncidentMessageAttributes!, id: ID!): IncidentMessage
  updateOidcProvider(attributes: OidcAttributes!, installationId: ID!): OidcProvider
  updatePlan(planId: ID!, subscriptionId: ID!): RepositorySubscription
  updatePlanAttributes(attributes: UpdatablePlanAttributes!, id: ID!): Plan
  updatePlatformPlan(planId: ID!): PlatformSubscription
  updatePublisher(attributes: PublisherAttributes!): Publisher
  updateRepository(attributes: RepositoryAttributes!, repositoryId: ID, repositoryName: String): Repository
  updateRole(attributes: RoleAttributes!, id: ID!): Role
  updateServiceAccount(attributes: ServiceAccountAttributes!, id: ID!): User
  updateShell(attributes: CloudShellAttributes!): CloudShell
  updateShellConfiguration(context: Map!): Boolean
  updateStep(attributes: TestStepAttributes!, id: ID!): TestStep
  updateTerraform(attributes: TerraformAttributes!, id: ID!): Terraform
  updateTest(attributes: TestAttributes!, id: ID!): Test
  updateUser(attributes: UserAttributes!, id: ID): User
  updateVersion(attributes: VersionAttributes!, id: ID, spec: VersionSpec): Version
  uploadTerraform(attributes: TerraformAttributes!, name: String!, repositoryName: String!): Terraform
  upsertOidcProvider(attributes: OidcAttributes!, installationId: ID!): OidcProvider
  upsertRepository(attributes: RepositoryAttributes!, name: String!, publisher: String!): Repository
}

type RootQueryType {
  account: Account
  auditMetrics: [GeoMetric]
  audits(after: String, before: String, first: Int, last: Int): AuditConnection
  categories: [CategoryInfo]
  category(name: Category!): CategoryInfo
  chart(id: ID!): Chart
  chartInstallations(after: String, before: String, first: Int, last: Int, repositoryId: ID!): ChartInstallationConnection
  charts(after: String, before: String, first: Int, last: Int, repositoryId: ID!): ChartConnection
  closure(id: ID!, type: DependencyType!): [ClosureItem]
  "Get a cluster by its ID."
  cluster(
    "The ID of the cluster."
    id: ID!
  ): Cluster
  "Get a list of clusters owned by the current account."
  clusters(after: String, before: String, first: Int, last: Int): ClusterConnection
  configuration: PluralConfiguration
  deferredUpdates(after: String, before: String, chartInstallationId: ID, first: Int, last: Int, terraformInstallationId: ID): DeferredUpdateConnection
  demoProject(id: ID): DemoProject
  dnsDomain(id: ID!): DnsDomain
  dnsDomains(after: String, before: String, first: Int, last: Int, q: String): DnsDomainConnection
  dnsRecords(after: String, before: String, cluster: String, domainId: ID, first: Int, last: Int, provider: Provider): DnsRecordConnection
  dockerImage(id: ID!): DockerImage
  dockerImages(after: String, before: String, dockerRepositoryId: ID!, first: Int, last: Int, q: String): DockerImageConnection
  dockerRepositories(after: String, before: String, first: Int, last: Int, repositoryId: ID!): DockerRepositoryConnection
  eabCredential(cluster: String!, provider: Provider!): EabCredential
  eabCredentials: [EabCredential]
  groupMembers(after: String, before: String, first: Int, groupId: ID!, last: Int): GroupMemberConnection
  groups(after: String, before: String, first: Int, last: Int, q: String): GroupConnection
  helpQuestion(prompt: String!): String
  incident(id: ID!): Incident
  incidents(after: String, before: String, filters: [IncidentFilter], first: Int, last: Int, order: Order, q: String, repositoryId: ID, sort: IncidentSort, supports: Boolean): IncidentConnection
  installation(id: ID, name: String): Installation
  installations(after: String, before: String, first: Int, last: Int): InstallationConnection
  integrationWebhook(id: ID!): IntegrationWebhook
  integrationWebhooks(after: String, before: String, first: Int, last: Int): IntegrationWebhookConnection
  integrations(after: String, before: String, first: Int, last: Int, repositoryId: ID, repositoryName: String, tag: String, type: String): IntegrationConnection
  invite(id: String!): Invite
  invites(after: String, before: String, first: Int, last: Int): InviteConnection
  invoices(after: String, before: String, first: Int, last: Int): InvoiceConnection
  keyBackup(name: String!): KeyBackup
  keyBackups(after: String, before: String, first: Int, last: Int): KeyBackupConnection
  loginMethod(email: String!, host: String): LoginMethodResponse
  loginMetrics: [GeoMetric]
  me: User
  notifications(after: String, before: String, cli: Boolean, first: Int, incidentId: ID, last: Int): NotificationConnection
  oauthConsent(challenge: String!): Repository
  oauthIntegrations: [OauthIntegration]
  oauthLogin(challenge: String!): Repository
  oauthUrls(host: String): [OauthInfo]
  oidcConsent(challenge: String!): OidcStepResponse
  oidcLogin(challenge: String!): OidcStepResponse
  oidcLogins(after: String, before: String, first: Int, last: Int): OidcLoginConnection
  platformMetrics: PlatformMetrics
  platformPlans: [PlatformPlan]
  platformSubscription: PlatformSubscription
  publicKeys(after: String, before: String, emails: [String], first: Int, last: Int): PublicKeyConnection
  publisher(id: ID): Publisher
  publishers(accountId: ID, after: String, before: String, first: Int, last: Int, publishable: Boolean): PublisherConnection
  recipe(id: ID, name: String, repo: String): Recipe
  recipes(after: String, before: String, first: Int, last: Int, provider: Provider, repositoryId: ID, repositoryName: String): RecipeConnection
  repositories(after: String, before: String, categories: [Category], category: Category, first: Int, installed: Boolean, last: Int, provider: Provider, publisherId: ID, publishers: [ID], q: String, supports: Boolean, tag: String, tags: [String]): RepositoryConnection
  "Get an application by its ID or name."
  repository(
    "The ID of the application."
    id: ID,
    "The name of the application."
    name: String
  ): Repository
  repositorySubscription(id: ID!): RepositorySubscription
  resetToken(id: ID!): ResetToken
  role(id: ID!): Role
  roles(after: String, before: String, first: Int, last: Int, q: String, userId: ID): RoleConnection
  rollouts(after: String, before: String, first: Int, last: Int, repositoryId: ID!): RolloutConnection
  scaffold(application: String!, category: Category!, ingress: Boolean, postgres: Boolean, publisher: String!): [ScaffoldFile]
  scmAuthorization: [AuthorizationUrl]
  scmToken(code: String!, provider: ScmProvider!): String
  searchRepositories(after: String, before: String, first: Int, last: Int, query: String!): RepositoryConnection
  searchUsers(after: String, before: String, first: Int, incidentId: ID!, last: Int, q: String!): UserConnection
  shell: CloudShell
  shellConfiguration: ShellConfiguration
  stack(name: String!, provider: Provider!): Stack
  stacks(after: String, before: String, featured: Boolean, first: Int, last: Int): StackConnection
  subscriptions(after: String, before: String, first: Int, last: Int): RepositorySubscriptionConnection
  tags(after: String, before: String, first: Int, id: ID, last: Int, q: String, type: TagGroup!): GroupedTagConnection
  terraform(after: String, before: String, first: Int, last: Int, repositoryId: ID!): TerraformConnection
  terraformInstallations(after: String, before: String, first: Int, last: Int, repositoryId: ID!): TerraformInstallationConnection
  terraformModule(id: ID!): Terraform
  terraformProvider(name: Provider!, vsn: String): TerraformProvider
  terraformProviders: [Provider]
  test(id: ID!): Test
  testLogs(id: ID!, step: ID!): String
  tests(after: String, before: String, first: Int, last: Int, repositoryId: ID, versionId: ID): TestConnection
  token(id: ID!): PersistedToken
  tokens(after: String, before: String, first: Int, last: Int): PersistedTokenConnection
  upgradeQueue(id: ID): UpgradeQueue
  upgradeQueues: [UpgradeQueue]
  users(after: String, all: Boolean, before: String, first: Int, last: Int, q: String, serviceAccount: Boolean): UserConnection
  versions(after: String, before: String, chartId: ID, first: Int, last: Int, terraformId: ID): VersionConnection
  webhooks(after: String, before: String, first: Int, last: Int): WebhookConnection
}

type RootSubscriptionType {
  incidentDelta(incidentId: ID, repositoryId: ID): IncidentDelta
  incidentMessageDelta(incidentId: ID): IncidentMessageDelta
  notification: Notification
  rolloutDelta(repositoryId: ID!): RolloutDelta
  testDelta(repositoryId: ID!): TestDelta
  testLogs(testId: ID!): StepLogs
  upgrade(id: ID): Upgrade
  upgradeQueueDelta: UpgradeQueueDelta
}

type ScaffoldFile {
  content: String
  path: String
}

type ScanError {
  message: String
}

type ScanViolation {
  category: String
  description: String
  file: String
  insertedAt: DateTime
  line: Int
  resourceName: String
  resourceType: String
  ruleId: String
  ruleName: String
  severity: VulnGrade
  updatedAt: DateTime
}

type ServiceLevel {
  maxSeverity: Int
  minSeverity: Int
  responseTime: Int
}

type ShellConfiguration {
  buckets: [String]
  contextConfiguration: Map
  domains: [String]
  git: GitConfiguration
  workspace: ShellWorkspace
}

type ShellStatus {
  containersReady: Boolean
  initialized: Boolean
  podScheduled: Boolean
  ready: Boolean
}

type ShellWorkspace {
  bucketPrefix: String
  cluster: String
  network: NetworkConfiguration
  region: String
}

type SlimSubscription {
  id: ID!
  lineItems: SubscriptionLineItems
  plan: Plan
}

type Stack {
  bundles: [Recipe]
  collections: [StackCollection]
  community: Community
  creator: User
  description: String
  displayName: String
  featured: Boolean
  id: ID!
  insertedAt: DateTime
  name: String!
  sections: [RecipeSection]
  updatedAt: DateTime
}

type StackCollection {
  bundles: [StackRecipe]
  id: ID!
  insertedAt: DateTime
  provider: Provider!
  updatedAt: DateTime
}

type StackConnection {
  edges: [StackEdge]
  pageInfo: PageInfo!
}

type StackEdge {
  cursor: String
  node: Stack
}

type StackRecipe {
  id: ID!
  insertedAt: DateTime
  recipe: Recipe!
  updatedAt: DateTime
}

type StepLogs {
  logs: [String]
  step: TestStep
}

type SubscriptionLineItems {
  items: [Limit]
}

type Tag {
  id: ID!
  tag: String!
}

type Terraform {
  dependencies: Dependencies
  description: String
  editable: Boolean
  id: ID
  insertedAt: DateTime
  installation: TerraformInstallation
  latestVersion: String
  name: String
  package: String
  readme: String
  repository: Repository
  updatedAt: DateTime
  valuesTemplate: String
}

type TerraformConnection {
  edges: [TerraformEdge]
  pageInfo: PageInfo!
}

type TerraformEdge {
  cursor: String
  node: Terraform
}

type TerraformInstallation {
  id: ID
  insertedAt: DateTime
  installation: Installation
  terraform: Terraform
  updatedAt: DateTime
  version: Version
}

type TerraformInstallationConnection {
  edges: [TerraformInstallationEdge]
  pageInfo: PageInfo!
}

type TerraformInstallationEdge {
  cursor: String
  node: TerraformInstallation
}

type TerraformProvider {
  content: String
  name: Provider
}

type Test {
  creator: User
  id: ID!
  insertedAt: DateTime
  name: String
  promoteTag: String!
  repository: Repository
  sourceTag: String!
  status: TestStatus!
  steps: [TestStep]
  tags: [String!]
  updatedAt: DateTime
}

type TestArgument {
  key: String!
  name: String!
  repo: String!
}

type TestConnection {
  edges: [TestEdge]
  pageInfo: PageInfo!
}

type TestDelta {
  delta: Delta
  payload: Test
}

type TestEdge {
  cursor: String
  node: Test
}

type TestStep {
  description: String!
  hasLogs: Boolean
  id: ID!
  insertedAt: DateTime
  name: String!
  status: TestStatus!
  updatedAt: DateTime
}

type Upgrade {
  id: ID!
  insertedAt: DateTime
  message: String
  repository: Repository
  type: UpgradeType
  updatedAt: DateTime
}

type UpgradeConnection {
  edges: [UpgradeEdge]
  pageInfo: PageInfo!
}

type UpgradeEdge {
  cursor: String
  node: Upgrade
}

"The pending upgrades for a repository"
type UpgradeInfo {
  count: Int
  installation: Installation
}

type UpgradeQueue {
  acked: ID
  domain: String
  git: String
  id: ID!
  insertedAt: DateTime
  name: String
  pingedAt: DateTime
  provider: Provider
  updatedAt: DateTime
  upgrades(after: String, before: String, first: Int, last: Int): UpgradeConnection
  user: User!
}

type UpgradeQueueDelta {
  delta: Delta
  payload: UpgradeQueue
}

type User {
  account: Account!
  address: Address
  avatar: String
  backgroundColor: String
  boundRoles: [Role]
  cards(after: String, before: String, first: Int, last: Int): CardConnection
  defaultQueueId: ID
  "If a user has reached the demo project usage limit."
  demoed: Boolean
  demoing: Boolean
  email: String!
  emailConfirmBy: DateTime
  emailConfirmed: Boolean
  hasInstallations: Boolean
  id: ID!
  impersonationPolicy: ImpersonationPolicy
  insertedAt: DateTime
  jwt: String
  loginMethod: LoginMethod
  name: String!
  onboarding: OnboardingState
  onboardingChecklist: OnboardingChecklist
  phone: String
  provider: Provider
  publisher: Publisher
  roles: Roles
  serviceAccount: Boolean
  updatedAt: DateTime
}

type UserConnection {
  edges: [UserEdge]
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String
  node: User
}

"The version of a package."
type Version {
  chart: Chart
  crds: [Crd]
  dependencies: Dependencies
  helm: Map
  id: ID!
  imageDependencies: [ImageDependency]
  insertedAt: DateTime
  package: String
  readme: String
  scan: PackageScan
  tags: [VersionTag]
  "The template engine used to render the valuesTemplate."
  templateType: TemplateType
  terraform: Terraform
  updatedAt: DateTime
  valuesTemplate: String
  version: String!
}

type VersionConnection {
  edges: [VersionEdge]
  pageInfo: PageInfo!
}

type VersionEdge {
  cursor: String
  node: Version
}

type VersionTag {
  chart: Chart
  id: ID!
  insertedAt: DateTime
  tag: String!
  updatedAt: DateTime
  version: Version
}

type Vulnerability {
  cvss: Cvss
  description: String
  fixedVersion: String
  id: ID!
  insertedAt: DateTime
  installedVersion: String
  layer: ImageLayer
  package: String
  score: Float
  severity: VulnGrade
  source: String
  title: String
  updatedAt: DateTime
  url: String
  vulnerabilityId: String
}

type Webhook {
  id: ID
  insertedAt: DateTime
  secret: String
  updatedAt: DateTime
  url: String
  user: User
}

type WebhookConnection {
  edges: [WebhookEdge]
  pageInfo: PageInfo!
}

type WebhookEdge {
  cursor: String
  node: Webhook
}

type WebhookLog {
  id: ID!
  insertedAt: DateTime
  payload: Map
  response: String
  state: WebhookLogState!
  status: Int
  updatedAt: DateTime
  webhook: IntegrationWebhook
}

type WebhookLogConnection {
  edges: [WebhookLogEdge]
  pageInfo: PageInfo!
}

type WebhookLogEdge {
  cursor: String
  node: WebhookLog
}

type WebhookResponse {
  body: String
  headers: Map
  statusCode: Int!
}

type Wirings {
  helm: Map
  terraform: Map
}

type ZoomMeeting {
  joinUrl: String!
  password: String
}

enum ActionItemType {
  BLOG
  ISSUE
  PULL
}

enum ArtifactPlatform {
  ANDROID
  FREEBSD
  LINUX
  MAC
  OPENBSD
  SOLARIS
  WINDOWS
}

enum ArtifactType {
  CLI
  DESKTOP
  MOBILE
}

"Application categories."
enum Category {
  DATA
  DATABASE
  DEVOPS
  MESSAGING
  NETWORK
  PRODUCTIVITY
  SECURITY
  STORAGE
}

enum Datatype {
  BOOL
  BUCKET
  DOMAIN
  FILE
  FUNCTION
  INT
  PASSWORD
  STRING
}

enum Delta {
  CREATE
  DELETE
  UPDATE
}

enum DemoProjectState {
  CREATED
  ENABLED
  READY
}

enum DependencyType {
  HELM
  TERRAFORM
}

enum DnsRecordType {
  A
  AAAA
  CNAME
  TXT
}

enum ImageGrade {
  A
  B
  C
  D
  F
}

enum IncidentAction {
  ACCEPT
  COMPLETE
  CREATE
  EDIT
  SEVERITY
  STATUS
}

enum IncidentFilterType {
  FOLLOWING
  NOTIFICATIONS
  STATUS
  TAG
}

enum IncidentSort {
  INSERTED_AT
  SEVERITY
  STATUS
  TITLE
}

enum IncidentStatus {
  COMPLETE
  IN_PROGRESS
  OPEN
  RESOLVED
}

enum LineItemDimension {
  CLUSTER
  USER
}

enum LoginMethod {
  GITHUB
  GOOGLE
  PASSWORD
  PASSWORDLESS
  SSO
}

enum MediaType {
  AUDIO
  IMAGE
  OTHER
  PDF
  VIDEO
}

enum MessageEntityType {
  EMOJI
  MENTION
}

enum NotificationType {
  INCIDENT_UPDATE
  LOCKED
  MENTION
  MESSAGE
}

enum OauthProvider {
  GITHUB
  GITLAB
  GOOGLE
}

enum OauthService {
  ZOOM
}

"Supported OIDC authentication methods."
enum OidcAuthMethod {
  BASIC
  POST
}

enum OnboardingChecklistState {
  CONFIGURED
  CONSOLE_INSTALLED
  FINISHED
  NEW
}

enum OnboardingState {
  ACTIVE
  INSTALLED
  NEW
  ONBOARDED
}

enum Operation {
  EQ
  GT
  GTE
  LT
  LTE
  NOT
  PREFIX
  SUFFIX
}

enum Order {
  ASC
  DESC
}

enum PaymentPeriod {
  MONTHLY
  YEARLY
}

enum Permission {
  BILLING
  INSTALL
  INTEGRATIONS
  PUBLISH
  SUPPORT
  USERS
}

enum PlanType {
  LICENSED
  METERED
}

enum Provider {
  AWS
  AZURE
  CUSTOM
  EQUINIX
  GCP
  GENERIC
  KIND
  KUBERNETES
}

enum RecipeItemType {
  HELM
  TERRAFORM
}

enum ResetTokenType {
  EMAIL
  PASSWORD
}

enum RolloutStatus {
  FINISHED
  QUEUED
  RUNNING
}

enum ScmProvider {
  DEMO
  GITHUB
  GITLAB
  MANUAL
}

"Possible cluster sources."
enum Source {
  DEFAULT
  DEMO
  SHELL
}

enum SpecDatatype {
  BOOL
  FLOAT
  INT
  LIST
  OBJECT
  STRING
}

enum TagGroup {
  INTEGRATIONS
  REPOSITORIES
}

"Template engines that can be used at build time."
enum TemplateType {
  GOTEMPLATE
  JAVASCRIPT
  LUA
}

enum TestStatus {
  FAILED
  QUEUED
  RUNNING
  SUCCEEDED
}

enum TestType {
  GIT
}

enum UpgradeType {
  APPROVAL
  BOUNCE
  DEDICATED
  DEPLOY
}

enum UserEventStatus {
  ERROR
  OK
}

enum ValidationType {
  REGEX
}

enum VulnGrade {
  CRITICAL
  HIGH
  LOW
  MEDIUM
  NONE
}

enum VulnRequirement {
  NONE
  REQUIRED
}

enum VulnVector {
  ADJACENT
  LOCAL
  NETWORK
  PHYSICAL
}

enum WebhookLogState {
  DELIVERED
  FAILED
  SENDING
}

"""

The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

scalar Map

scalar UploadOrUrl

scalar Yaml

input AccountAttributes {
  billingAddress: AddressAttributes
  domainMappings: [DomainMappingInput]
  icon: UploadOrUrl
  name: String
}

input ActionItemAttributes {
  link: String!
  type: ActionItemType!
}

input AddressAttributes {
  city: String!
  country: String!
  line1: String!
  line2: String!
  name: String
  state: String!
  zip: String!
}

input ArtifactAttributes {
  arch: String
  blob: UploadOrUrl
  name: String!
  platform: String!
  readme: String!
  type: String!
}

input AwsShellCredentialsAttributes {
  accessKeyId: String!
  secretAccessKey: String!
}

input AzureShellCredentialsAttributes {
  clientId: String!
  clientSecret: String!
  storageAccount: String!
  subscriptionId: String!
  tenantId: String!
}

input BindingAttributes {
  groupId: ID
  id: ID
  userId: ID
}

input ChartAttributes {
  tags: [VersionTagAttributes]
}

input ChartInstallationAttributes {
  chartId: ID
  versionId: ID
}

input ChartName {
  chart: String
  repo: String
}

input CloudShellAttributes {
  credentials: ShellCredentialsAttributes!
  demoId: ID
  provider: Provider
  scm: ScmAttributes
  workspace: WorkspaceAttributes!
}

"Input for creating or updating a cluster."
input ClusterAttributes {
  "The URL of the console running on the cluster."
  consoleUrl: String
  "The domain name used for applications deployed on the cluster."
  domain: String
  "The git repository URL for the cluster."
  gitUrl: String
  "The name of the cluster."
  name: String!
  "The cluster's cloud provider."
  provider: Provider!
  "The source of the cluster."
  source: Source
}

input ClusterInformationAttributes {
  gitCommit: String
  platform: String
  version: String
}

"Input for creating or updating the community links of an application."
input CommunityAttributes {
  "The application's Discord server."
  discord: String
  "The application's git URL."
  gitUrl: String
  "The application's homepage."
  homepage: String
  "The application's Slack channel."
  slack: String
  "The application's Twitter account."
  twitter: String
  "The videos of the application."
  videos: [String]
}

input ContextAttributes {
  buckets: [String]
  configuration: Map!
  domains: [String]
}

input CrdAttributes {
  blob: UploadOrUrl
  name: String!
}

input DnsAccessPolicyAttributes {
  bindings: [BindingAttributes]
  id: ID
}

input DnsDomainAttributes {
  accessPolicy: DnsAccessPolicyAttributes
  name: String
}

input DnsRecordAttributes {
  name: String!
  records: [String]
  type: DnsRecordType!
}

input DockerRepositoryAttributes {
  public: Boolean!
}

input DomainMappingInput {
  domain: String
  enableSso: Boolean
  id: ID
}

input EntityAttributes {
  endIndex: Int
  startIndex: Int
  text: String
  type: MessageEntityType!
  userId: ID
}

input FileAttributes {
  blob: UploadOrUrl
}

input FollowerAttributes {
  preferences: NotificationPreferencesAttributes
}

input GcpShellCredentialsAttributes {
  applicationCredentials: String!
}

input GroupAttributes {
  description: String
  global: Boolean
  name: String!
}

input ImpersonationPolicyAttributes {
  bindings: [ImpersonationPolicyBindingAttributes]
  id: ID
}

input ImpersonationPolicyBindingAttributes {
  groupId: ID
  id: ID
  userId: ID
}

input IncidentAttributes {
  clusterInformation: ClusterInformationAttributes
  description: String
  severity: Int
  status: IncidentStatus
  tags: [TagAttributes]
  title: String
}

input IncidentFilter {
  statuses: [IncidentStatus]
  type: IncidentFilterType!
  value: String
}

input IncidentMessageAttributes {
  entities: [EntityAttributes]
  file: FileAttributes
  text: String!
}

"Input for creating or updating the tag attributes of an application installation."
input InstallationAttributes {
  "Whether the application should auto upgrade."
  autoUpgrade: Boolean
  "A YAML object of context."
  context: Yaml
  "The tag to track for auto upgrades."
  trackTag: String
}

input IntegrationAttributes {
  description: String
  icon: UploadOrUrl
  name: String!
  sourceUrl: String
  spec: Yaml
  tags: [TagAttributes]
  type: String
}

input IntegrationWebhookAttributes {
  actions: [String]
  name: String!
  url: String!
}

input InviteAttributes {
  email: String
}

input KeyBackupAttributes {
  key: String!
  name: String!
  repositories: [String]
}

input LimitAttributes {
  dimension: String!
  quantity: Int!
}

input LineItemAttributes {
  cost: Int!
  dimension: String!
  name: String!
  period: String!
  type: PlanType
}

input LockAttributes {
  lock: String!
}

input MeetingAttributes {
  incidentId: ID
  topic: String!
}

input NotificationPreferencesAttributes {
  incidentUpdate: Boolean!
  mention: Boolean!
  message: Boolean!
}

input OauthAttributes {
  code: String
  redirectUri: String
  service: OauthService
}

"Input for the application's OAuth settings."
input OauthSettingsAttributes {
  "The authentication method for the OAuth provider."
  authMethod: OidcAuthMethod!
  "The URI format for the OAuth provider."
  uriFormat: String!
}

"Input for creating or updating the OIDC attributes of an application installation."
input OidcAttributes {
  "The authentication method for the OIDC provider."
  authMethod: OidcAuthMethod!
  "The users or groups that can login through the OIDC provider."
  bindings: [BindingAttributes]
  "The redirect URIs for the OIDC provider."
  redirectUris: [String]
}

input OidcSettingsAttributes {
  authMethod: OidcAuthMethod!
  domainKey: String
  subdomain: Boolean
  uriFormat: String
  uriFormats: [String]
}

input OnboardingChecklistAttributes {
  dismissed: Boolean
  status: OnboardingChecklistState
}

input PlanAttributes {
  cost: Int!
  default: Boolean
  lineItems: PlanLineItemAttributes
  metadata: PlanMetadataAttributes
  name: String!
  period: String!
  serviceLevels: [ServiceLevelAttributes]
}

input PlanFeatureAttributes {
  description: String!
  name: String!
}

input PlanLineItemAttributes {
  included: [LimitAttributes]
  items: [LineItemAttributes]
}

input PlanMetadataAttributes {
  features: [PlanFeatureAttributes]
  freeform: Yaml
}

input PostmortemAttributes {
  actionItems: [ActionItemAttributes]
  content: String!
}

input PublicKeyAttributes {
  content: String!
  name: String!
}

input PublisherAttributes {
  address: AddressAttributes
  avatar: UploadOrUrl
  community: CommunityAttributes
  description: String
  name: String
  phone: String
}

input RecipeAttributes {
  dependencies: [RecipeReference]
  description: String
  name: String!
  oidcSettings: OidcSettingsAttributes
  primary: Boolean
  private: Boolean
  provider: Provider
  restricted: Boolean
  sections: [RecipeSectionAttributes]
  tests: [RecipeTestAttributes]
}

input RecipeConditionAttributes {
  field: String!
  operation: Operation!
  value: String
}

input RecipeConfigurationAttributes {
  condition: RecipeConditionAttributes
  default: String
  documentation: String
  functionName: String
  longform: String
  name: String!
  optional: Boolean
  placeholder: String
  type: Datatype!
  validation: RecipeValidationAttributes
}

input RecipeItemAttributes {
  configuration: [RecipeConfigurationAttributes]
  name: String!
  type: RecipeItemType!
}

input RecipeReference {
  name: String!
  repo: String!
}

input RecipeSectionAttributes {
  configuration: [RecipeConfigurationAttributes]
  items: [RecipeItemAttributes]
  name: String!
}

input RecipeTestAttributes {
  args: [TestArgumentAttributes]
  message: String
  name: String!
  type: TestType!
}

input RecipeValidationAttributes {
  message: String!
  regex: String
  type: ValidationType!
}

"Input for creating or updating an application's attributes."
input RepositoryAttributes {
  "The category of the application."
  category: Category
  "The application's community links."
  community: CommunityAttributes
  "The application's dark icon."
  darkIcon: UploadOrUrl
  "The default tag to use when deploying the application."
  defaultTag: String
  "A short description of the application."
  description: String
  "The application's documentation."
  docs: UploadOrUrl
  "A link to the application's documentation."
  documentation: String
  "The application's git URL."
  gitUrl: String
  "The application's homepage."
  homepage: String
  "The application's icon."
  icon: UploadOrUrl
  "The application's integration resource definition."
  integrationResourceDefinition: ResourceDefinitionAttributes
  "The name of the application."
  name: String
  "Notes about the application rendered after deploying and displayed to the user."
  notes: String
  "The application's OAuth settings."
  oauthSettings: OauthSettingsAttributes
  "Whether the application is private."
  private: Boolean
  "The application's README."
  readme: String
  "A YAML object of secrets."
  secrets: Yaml
  "The application's tags."
  tags: [TagAttributes]
  "Whether the application is trending."
  trending: Boolean
  "Whether the application is verified."
  verified: Boolean
}

input ResetTokenAttributes {
  email: String
  type: ResetTokenType!
}

input ResetTokenRealization {
  password: String
}

input ResourceDefinitionAttributes {
  name: String!
  spec: [SpecificationAttributes]
}

input RoleAttributes {
  description: String
  name: String
  permissions: [Permission]
  repositories: [String]
  roleBindings: [BindingAttributes]
}

input RolesAttributes {
  admin: Boolean
}

input ScmAttributes {
  gitUrl: String
  name: String
  org: String
  privateKey: String
  provider: ScmProvider
  publicKey: String
  token: String
}

input ServiceAccountAttributes {
  email: String
  impersonationPolicy: ImpersonationPolicyAttributes
  name: String
}

input ServiceLevelAttributes {
  maxSeverity: Int
  minSeverity: Int
  responseTime: Int
}

input ShellCredentialsAttributes {
  aws: AwsShellCredentialsAttributes
  azure: AzureShellCredentialsAttributes
  gcp: GcpShellCredentialsAttributes
}

input SpecificationAttributes {
  inner: SpecDatatype
  name: String!
  required: Boolean
  spec: [SpecificationAttributes]
  type: SpecDatatype!
}

input StackAttributes {
  collections: [StackCollectionAttributes]
  community: CommunityAttributes
  description: String
  displayName: String
  featured: Boolean
  name: String!
}

input StackCollectionAttributes {
  bundles: [RecipeReference]
  provider: Provider!
}

input SubscriptionAttributes {
  lineItems: SubscriptionLineItemAttributes
}

input SubscriptionLineItemAttributes {
  items: [LimitAttributes]
}

input TagAttributes {
  tag: String!
}

input TerraformAttributes {
  dependencies: Yaml
  description: String
  name: String
  package: UploadOrUrl
  version: String
}

input TerraformInstallationAttributes {
  terraformId: ID
  versionId: ID
}

input TestArgumentAttributes {
  key: String!
  name: String!
  repo: String!
}

input TestAttributes {
  name: String
  promoteTag: String
  status: TestStatus
  steps: [TestStepAttributes]
  tags: [String]
}

input TestStepAttributes {
  description: String
  id: ID
  logs: UploadOrUrl
  name: String
  status: TestStatus
}

input UpdatablePlanAttributes {
  default: Boolean
  serviceLevels: [ServiceLevelAttributes]
}

input UpgradeQueueAttributes {
  domain: String
  git: String
  name: String!
  provider: Provider
}

input UserAttributes {
  avatar: UploadOrUrl
  confirm: String
  email: String
  loginMethod: LoginMethod
  name: String
  onboarding: OnboardingState
  onboardingChecklist: OnboardingChecklistAttributes
  password: String
  roles: RolesAttributes
}

input UserEventAttributes {
  data: String
  event: String!
  status: UserEventStatus
}

input VersionAttributes {
  tags: [VersionTagAttributes]
}

input VersionSpec {
  chart: String
  repository: String
  terraform: String
  version: String
}

input VersionTagAttributes {
  tag: String!
  versionId: ID
}

input WebhookAttributes {
  url: String!
}

input WorkspaceAttributes {
  bucketPrefix: String!
  cluster: String!
  project: String
  region: String!
  subdomain: String!
}
