package scaffold

import (
	"bytes"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"golang.org/x/mod/semver"

	"github.com/pluralsh/plural/pkg/api"
	"github.com/pluralsh/plural/pkg/template"
	"github.com/pluralsh/plural/pkg/utils"
	"github.com/pluralsh/plural/pkg/utils/pathing"
	"github.com/pluralsh/plural/pkg/wkspace"
)

const moduleTemplate = `module "{{ .Values.name }}" {
  source = "{{ .Values.path }}"

### BEGIN MANUAL SECTION <<{{ .Values.name }}>>
{{ .Values.Manual }}
### END MANUAL SECTION <<{{ .Values.name }}>>

{{ .Values.conf | nindent 2 }}
{{ range $key, $val := .Values.deps }}
  {{ $key }} = module.{{ $val }}
{{- end }}
}
`

const outputTemplate = `output "{{ .Name }}" {
	value = module.{{ .Module }}.{{ .Value }}
	sensitive = true
}
`

const customRoute53Template = `
data "aws_route53_zone" "prod" {
  name = "{{ .AppDomain }}"
}

resource "aws_route53_zone" "dev" {
  name = "dev.{{ .AppDomain }}"
}

resource "aws_route53_record" "dev-ns" {
  zone_id = data.aws_route53_zone.prod.zone_id
  name    = "dev.{{ .AppDomain }}"
  type    = "NS"
  ttl     = "30"
  records = aws_route53_zone.dev.name_servers
}
`

const customAzureDnsTemplate = `
data "azurerm_dns_zone" "prod" {
  name                = "{{ .AppDomain }}"
  resource_group_name = "{{ .ResourceGroupName }}"
}

resource "azurerm_dns_zone" "dev" {
  name                = "dev.{{ .AppDomain }}"
  resource_group_name = "{{ .ResourceGroupName }}"
}

resource "azurerm_dns_ns_record" "dev_ns" {
  name                = "dev"
  zone_name           = data.azurerm_dns_zone.prod.name
  resource_group_name = data.azurerm_dns_zone.prod.resource_group_name
  ttl                 = 30
  records             = azurerm_dns_zone.dev.name_servers
}
`

const customGcpCloudDnsTemplate = `
data "google_dns_managed_zone" "prod" {
  name    = "{{ replace .AppDomain \".\" \"-\" }}-prod" // GCP names often have restrictions
  project = "{{ .Project }}"
}

resource "google_dns_managed_zone" "dev" {
  name        = "{{ replace .AppDomain \".\" \"-\" }}-dev" // GCP names often have restrictions
  dns_name    = "dev.{{ .AppDomain }}." // Note the trailing dot
  project     = "{{ .Project }}"
  description = "Dev zone for {{ .AppDomain }}"
}

resource "google_dns_record_set" "dev_ns" {
  name         = "dev.{{ .AppDomain }}." // Note the trailing dot
  managed_zone = data.google_dns_managed_zone.prod.name
  project      = data.google_dns_managed_zone.prod.project
  type         = "NS"
  ttl          = 30
  rrdatas      = google_dns_managed_zone.dev.name_servers
}
`

const helpDoc = `
############## Helpful Hints ###################

# Any configuration updates should be done in this file in a manual section. You can also create files alongside this one, 
# and plural build will preserve them.  That's the ideal strategy if you want to add additional resources like a sql instance
# or vpn gateway.

# The submodule folders within this directory are generated by plural build and we cannot guarantee a change in 
# them will be merged properly.

#################################################

`

func (scaffold *Scaffold) handleTerraform(wk *wkspace.Workspace) error {
	repo := wk.Installation.Repository
	providerCtx := buildContext(wk, repo.Name, wk.Terraform)

	var providerVersions semver.ByVersion

	for i := range wk.Terraform {
		providerVersions = append(providerVersions, wk.Terraform[i].Terraform.Dependencies.ProviderVsn)
	}

	semver.Sort(providerVersions)

	// use the latest version of the TF template for the provider
	backend, err := wk.Provider.CreateBackend(repo.Name, providerVersions[providerVersions.Len()-1], providerCtx)
	if err != nil {
		return err
	}

	apps, err := NewApplications()
	if err != nil {
		return err
	}

	if err := scaffold.untarModules(wk); err != nil {
		return err
	}

	mainFile := pathing.SanitizeFilepath(filepath.Join(scaffold.Root, "main.tf"))
	contents, err := utils.ReadFile(mainFile)
	if err != nil {
		contents = ""
	}

	var modules = make([]string, len(wk.Terraform)+1)
	modules[0] = helpDoc + backend
	ctx, _ := wk.Context.Repo(repo.Name)
	links := wk.Links
	for i, tfInst := range wk.Terraform {
		tf := tfInst.Terraform
		linkPath := ""
		if links != nil {
			if path, ok := links.Terraform[tf.Name]; ok {
				linkPath = path
			}
		}

		var buf bytes.Buffer
		buf.Grow(5 * 1024)
		plate := tfInst.Version.ValuesTemplate
		if linkPath != "" {
			var err error
			plate, err = utils.ReadFile(pathing.SanitizeFilepath(filepath.Join(linkPath, "terraform.tfvars")))
			if err != nil {
				return err
			}
		}

		tmpl, err := template.MakeTemplate(plate)
		if err != nil {
			return err
		}
		values := map[string]interface{}{
			"Values":        ctx,
			"Configuration": wk.Context.Configuration,
			"Cluster":       wk.Provider.Cluster(),
			"Project":       wk.Provider.Project(),
			"Namespace":     wk.Config.Namespace(repo.Name),
			"Region":        wk.Provider.Region(),
			"Context":       wk.Provider.Context(),
			"Applications":  apps,
			"AppDomain":     wk.Manifest.AppDomain,
		}
		if err := tmpl.Execute(&buf, values); err != nil {
			return err
		}

		module := make(map[string]interface{})
		module["name"] = tf.Name
		if linkPath != "" {
			module["path"] = linkPath
		} else {
			module["path"] = "./" + tf.Name
		}

		module["conf"] = buf.String()
		if tf.Dependencies != nil && tf.Dependencies.Wirings != nil {
			module["deps"] = tf.Dependencies.Wirings.Terraform
		} else {
			module["deps"] = map[string]interface{}{}
		}
		module["Manual"] = manualSection(contents, tf.Name)

		var moduleBuf bytes.Buffer
		moduleBuf.Grow(1024)
		if err := template.RenderTemplate(&moduleBuf, moduleTemplate, module); err != nil {
			return err
		}

		modules[i+1] = moduleBuf.String()

		valuesFile := pathing.SanitizeFilepath(filepath.Join(scaffold.Root, tf.Name, "terraform.tfvars"))
		os.Remove(valuesFile)

		moduleBuf.Reset()
		buf.Reset()
	}

	if wk.Manifest.AppDomain != "" {
		if wk.Provider.Name() == "aws" {
			var r53Buf bytes.Buffer
			r53Ctx := map[string]interface{}{"AppDomain": wk.Manifest.AppDomain}

			customTmpl, err := template.MakeTemplate(customRoute53Template)
			if err != nil {
				return fmt.Errorf("failed to make custom route53 template: %w", err)
			}
			if err := customTmpl.Execute(&r53Buf, r53Ctx); err != nil {
				return fmt.Errorf("failed to render custom route53 template: %w", err)
			}
			modules = append(modules, "\n# Custom AWS Route53 Configuration (generated by Plural CLI)\n"+r53Buf.String())
		} else if wk.Provider.Name() == "azure" {
			var azureBuf bytes.Buffer
			azureCtx := map[string]interface{}{"AppDomain": wk.Manifest.AppDomain, "ResourceGroupName": wk.Provider.Project()}

			azureTmpl, err := template.MakeTemplate(customAzureDnsTemplate)
			if err != nil {
				return fmt.Errorf("failed to make custom Azure DNS template: %w", err)
			}
			if err := azureTmpl.Execute(&azureBuf, azureCtx); err != nil {
				return fmt.Errorf("failed to render custom Azure DNS template: %w", err)
			}
			modules = append(modules, "\n# Custom Azure DNS Configuration (generated by Plural CLI)\n"+azureBuf.String())
		} else if wk.Provider.Name() == "gcp" {
			var gcpBuf bytes.Buffer
			gcpCtx := map[string]interface{}{"AppDomain": wk.Manifest.AppDomain, "Project": wk.Provider.Project()}

			gcpTmpl, err := template.MakeTemplate(customGcpCloudDnsTemplate)
			if err != nil {
				return fmt.Errorf("failed to make custom GCP Cloud DNS template: %w", err)
			}
			if err := gcpTmpl.Execute(&gcpBuf, gcpCtx); err != nil {
				return fmt.Errorf("failed to render custom GCP Cloud DNS template: %w", err)
			}
			modules = append(modules, "\n# Custom GCP Cloud DNS Configuration (generated by Plural CLI)\n"+gcpBuf.String())
		}
	}

	if err := utils.WriteFile(mainFile, []byte(strings.Join(modules, "\n\n"))); err != nil {
		return err
	}

	if err := scaffold.buildOutputs(wk); err != nil {
		return err
	}

	secrets := buildTfSecrets(wk.Terraform)
	if err := buildSecrets(pathing.SanitizeFilepath(filepath.Join(scaffold.Root, ".gitattributes")), secrets); err != nil {
		return err
	}

	return nil
}

// TODO: move to some sort of scaffold util?
func (scaffold *Scaffold) untarModules(wk *wkspace.Workspace) error {
	length := len(wk.Terraform)
	utils.Highlight("unpacking %d %s", len(wk.Terraform), utils.Pluralize("module", "modules", length))
	for _, tfInst := range wk.Terraform {
		tf := tfInst.Terraform
		v := tfInst.Version
		path := pathing.SanitizeFilepath(filepath.Join(scaffold.Root, tf.Name))
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			fmt.Print("\n")
			return err
		}

		if err := untar(v, tf, path); err != nil {
			fmt.Print("\n")
			return err
		}
		fmt.Print(".")
	}

	utils.Success("\u2713\n")
	return nil
}

func (scaffold *Scaffold) buildOutputs(wk *wkspace.Workspace) error {
	var buf bytes.Buffer
	buf.Grow(5 * 1024)

	tmp, err := template.MakeTemplate(outputTemplate)
	if err != nil {
		return err
	}

	sort.SliceStable(wk.Terraform, func(i, j int) bool {
		return wk.Terraform[i].Terraform.Name < wk.Terraform[j].Terraform.Name
	})
	for _, tfInst := range wk.Terraform {
		tfName := tfInst.Terraform.Name
		for name, value := range tfInst.Version.Dependencies.Outputs {
			err = tmp.Execute(&buf, map[string]interface{}{"Name": name, "Value": value, "Module": tfName})
			if err != nil {
				return err
			}
			buf.WriteString("\n\n")
		}
	}

	outputFile := pathing.SanitizeFilepath(filepath.Join(scaffold.Root, "outputs.tf"))
	return utils.WriteFile(outputFile, buf.Bytes())
}

func untar(v *api.Version, tf *api.Terraform, dir string) error {
	resp, err := http.Get(v.Package)
	if err != nil {
		return err
	}

	return utils.Untar(resp.Body, dir, tf.Name)
}

func manualSection(contents, name string) string {
	re := regexp.MustCompile(fmt.Sprintf(`(?s)### BEGIN MANUAL SECTION <<%s>>(.*)### END MANUAL SECTION <<%s>>`, name, name))
	matches := re.FindStringSubmatch(contents)
	if len(matches) > 0 {
		return strings.TrimSpace(matches[1])
	}

	return ""
}

func buildTfSecrets(installations []*api.TerraformInstallation) []string {
	res := []string{}
	for _, inst := range installations {
		res = append(res, inst.Version.Dependencies.Secrets...)
	}
	return res
}

func buildContext(wk *wkspace.Workspace, repo string, installations []*api.TerraformInstallation) map[string]interface{} {
	ctx := map[string]interface{}{
		"Namespace": wk.Config.Namespace(repo),
	}

	for _, inst := range installations {
		for k, v := range inst.Version.Dependencies.ProviderWirings {
			if k == "cluster" {
				ctx["Cluster"] = v
			}
			ctx[k] = v
		}
	}

	return ctx
}
